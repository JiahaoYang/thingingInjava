RTTI：runtime type identify
查看一个引用的RTTI和class对象密不可分，这个对象是一个特殊对象，和类同生共死。class对象中包含了类的所有信息，比如类名。当我们编译一个类后，编译器会生成相应的class对象，并将该类和class对象一同写到了.class文件中。当类加载器加载类时会连同class对象一同加载到内存。而当我们创建对象时，JVM虚拟机是根据class对象创建出普通对象的，这样做后，普通对象中将会持有class对象的引用。现在事情就很简单了，JVM通过引用找到普通对象，通过普通对象中的引用找到class对象，通过class对象查到了类信息，这时一个引用的RTTI就被获得了。


List<Shape> list: 当从容器中取出元素时，它实际上将所有事物都当成Object对象持有，取出时将结果转型为Shape。在java中，所有类型转换都是在运行时进行正确性检查
Object转型为Shape，通过多态简化代码，但无法得知某个泛化shape引用的确切类型，不能进行特殊的处理。使用RTTI可以查询某个shape引用的确切类型

每当编写了一个新类，就会产生一个class对象（保存在同名的.class文件中），当第一次使用该类时（引用静态域）查找.class文件并加载类

Class.forName():在运行时获得类型信息，首先要获得class对象的引用（不用持有该实际对象）
如果已经有了对象，objName.getClass()获得class对象引用
通过class对象，可以了解类型的全部信息
getSuperClass()：完整的类继承
class.newInstance():实现“虚拟构造器”，得到object的引用，向下转型到具体类型，需要默认构造器，否则抛出IllegalAccessException

CLassName.class 使用类字面量获得class对象的引用
为使用类做得准备步骤：
1）加载，在classpath中查找.class文件，从字节码中创建class对象
2）链接，为静态域分配空间，解析这个类创建的对其他类的引用
3）初始化，初始化超类

RTTI:
1)传统的类型转换，（Shape）xxx
2)通过class对象在运行时获得类型信息
3）instanceof

instanceof, Isinstance:“你是这个类或者派生类吗”
== ， eauals   “你是这个确切的类吗”


反射：
RTTI的限制：能在运行时获得类型信息，但所有的类必须在编译时已知
从网络获得了一串字节，并被告知这个字节代表了一个类，但在自己的程序被编译时并不知道这个类型，无法通过RTTI使用这个类
反射提供了一种机制，可以检查类可用的方法，并返回方法名（分布式计算，将一个对象分布到多台机器上，通过反射获得对象的方法）
RTTI的应用场景是这样的：给一个引用，然后识别这个引用的类型信息，它需要建立在类已知的基础上，即编译器见过这个类，那么JVM或者在我们代码中才能获取一个引用的RTTI。
通过反射也能获取类型信息，它是在我们不知道类信息的基础上来做的。比如某个类没有在本地存储，而是在将来的某个时刻会通过网络发送过来。那么我们在代码中无法通过new的方式来创建这个类的对象，也不能调用其方法(如果这样做，编译器会报错说找不到该类），

Field，Constructor，Method对象由jvm在运行时创建，用于表示未知类的成员
用constructor创建新对象
用get，set修改field相关联的字段
用invoke()调用与method相关联的方法

当通过反射操作对象时，jvm只是简单地查看这个对象属于哪个类，在做进一步操作前必须加载那个类的class对象。（要么在本地机器上，要么通过网络获得）
RTTI：在编译时打开和检查.class文件
反射：在运行时打开和检查.class文件

代理：用户不想或不能直接引用一个对象，通过代理能去掉用户不可见的内容或添加额外服务
实际对象作为代理类的内部成员对象，每个实际类必须对应一个代理类，类个数太多
动态代理：将所有调用重定向到调用处理器

空对象：代替检查null引用

接口与类型信息：
通过反射可以获得对象的所有方法的名字和签名，然后调用他们（private也是！）

不要过早关注程序的效率问题，先让其运行起来！ 